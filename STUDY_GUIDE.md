# codesession-cli: Line-by-Line Study Guide

Read this top to bottom. Every file, every line, explained in plain English.
Estimated read time: 3-4 hours if you go slow.

---

## 1. src/types.ts (The Data Model)

This is the foundation. Every other file uses these shapes.

```typescript
export interface Session {
  id?: number;              // Auto-generated by SQLite (AUTOINCREMENT)
  name: string;             // User-given name like "fix auth bug"
  startTime: string;        // ISO timestamp: "2026-02-16T04:07:12.854Z"
  endTime?: string;         // Filled when session ends
  duration?: number;        // Calculated: endTime - startTime, in seconds
  workingDirectory: string; // The folder this session tracks (resolved to git root if in a repo)
  gitRoot?: string;         // The root of the git repo (if inside one)
  startGitHead?: string;    // The git commit SHA when session started (for diffing later)
  filesChanged: number;     // Counter: how many unique files were touched
  commits: number;          // Counter: how many git commits happened
  aiCost: number;           // Running total: dollars spent on AI
  aiTokens: number;         // Running total: all tokens used
  notes?: string;           // End-of-session notes (from cs end -n "notes")
  status: 'active' | 'completed'; // Only two states
}
```

**Why `id?` (optional)?** Because when creating a session, you don't know the ID yet.
SQLite assigns it. After creation, it's always present.

```typescript
export interface FileChange {
  id?: number;
  sessionId: number;        // Foreign key -> sessions.id
  filePath: string;         // Relative path like "src/index.ts"
  changeType: 'created' | 'modified' | 'deleted';
  timestamp: string;
}
```

Every time a file changes during a session, one of these records is created.

```typescript
export interface Commit {
  id?: number;
  sessionId: number;
  hash: string;             // Short hash like "abc1234" (first 7 chars)
  message: string;          // Commit message
  timestamp: string;
}
```

Git commits detected during a session.

```typescript
export interface AIUsage {
  id?: number;
  sessionId: number;
  provider: string;         // "anthropic", "openai", "google"
  model: string;            // "claude-sonnet-4", "gpt-4o"
  tokens: number;           // Total tokens (prompt + completion)
  promptTokens?: number;    // Input tokens (what you sent to the model)
  completionTokens?: number;// Output tokens (what the model replied)
  cost: number;             // Dollar cost of this single API call
  agentName?: string;       // "Claude Code", "Research Agent", etc.
  timestamp: string;
}
```

Every AI API call logged. This is the core value of the tool.

```typescript
export interface SessionStats {
  totalSessions: number;
  totalTime: number;        // Total seconds across all completed sessions
  totalFiles: number;
  totalCommits: number;
  totalAICost: number;
  avgSessionTime: number;
}
```

Aggregated stats across all sessions.

```typescript
export interface SessionNote {
  id?: number;
  sessionId: number;
  message: string;          // "started refactoring auth module"
  timestamp: string;
}
```

Timestamped annotations users can add during a session.

---

## 2. src/db.ts (The Database Layer)

This is the biggest file. It handles all data storage using SQLite.

### Imports & Setup (lines 1-7)

```typescript
import Database from 'better-sqlite3';  // SQLite library for Node.js (synchronous, fast)
import { join } from 'path';            // join('a', 'b') => 'a/b' (path concatenation)
import { homedir } from 'os';           // Returns user's home directory (~/)
import { existsSync, mkdirSync, readFileSync, writeFileSync, copyFileSync } from 'fs';
// ^ File system operations: check if file exists, create directory, read/write/copy files
import { Session, FileChange, Commit, AIUsage, SessionStats, SessionNote } from './types';
import { cleanupGit } from './git';
import { cleanupWatcher } from './watcher';
```

**Why better-sqlite3?** It's synchronous (no async/await needed for DB queries), which makes the code simpler. It's also the fastest SQLite library for Node.js.

### Data Directory & Migration (lines 9-44)

```typescript
const NEW_DB_DIR = join(homedir(), '.codesession');  // ~/.codesession
const LEGACY_DB_DIR = join(homedir(), '.devsession'); // ~/.devsession (old name)
```

The tool was originally called "devsession" and renamed to "codesession". This code migrates data from the old location.

```typescript
if (existsSync(LEGACY_DB_DIR) && !existsSync(NEW_DB_DIR)) {
  mkdirSync(NEW_DB_DIR, { recursive: true });
  // ... copies old DB to new location
  // ... verifies the copy isn't corrupted using SQLite integrity_check
  // ... also copies pricing.json if it exists
}
```

**Why check integrity?** If the copy was interrupted (disk full, crash), the DB file could be corrupt. `integrity_check` is SQLite's built-in corruption detector.

### Database Initialization (lines 46-50)

```typescript
const db = new Database(DB_PATH);  // Opens (or creates) the SQLite file

db.pragma('journal_mode = WAL');   // Write-Ahead Logging: allows concurrent reads while writing
db.pragma('busy_timeout = 5000');  // Wait 5 seconds if another process has the DB locked
```

**WAL mode** is important because the CLI and dashboard might access the DB simultaneously. Without WAL, one would block the other.

### Table Creation (lines 52-136)

```sql
CREATE TABLE IF NOT EXISTS sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Auto-incrementing unique ID
  name TEXT NOT NULL,                     -- Session name
  start_time TEXT NOT NULL,              -- ISO timestamp string
  end_time TEXT,                         -- NULL while active
  duration INTEGER,                      -- Calculated on end
  working_directory TEXT NOT NULL,       -- Folder being tracked
  git_root TEXT,                         -- Git repo root (if applicable)
  start_git_head TEXT,                   -- Git HEAD SHA at start
  files_changed INTEGER DEFAULT 0,      -- Counter, updated via triggers
  commits INTEGER DEFAULT 0,            -- Counter, updated via triggers
  ai_cost REAL DEFAULT 0,               -- Running total, REAL = floating point
  ai_tokens INTEGER DEFAULT 0,          -- Running total
  notes TEXT,                            -- End-of-session notes
  status TEXT DEFAULT 'active'          -- 'active' or 'completed'
)
```

**`CREATE TABLE IF NOT EXISTS`** means it only creates the table if it doesn't already exist. Safe to run every time the app starts.

The other tables (`file_changes`, `commits`, `ai_usage`, `session_notes`) follow the same pattern. Each has a `session_id` FOREIGN KEY linking back to the `sessions` table.

### Migrations (lines 109-136)

```typescript
try {
  db.exec('ALTER TABLE ai_usage ADD COLUMN prompt_tokens INTEGER');
} catch (_) { /* column already exists */ }
```

**Why try/catch?** SQLite throws an error if you try to add a column that already exists. We catch and ignore it. This is a simple migration strategy: try to add new columns, silently skip if they already exist. Runs on every startup.

### CRUD Functions (lines 138-268)

**createSession** (line 138):
```typescript
export function createSession(session: Omit<Session, 'id'>): number {
  // Omit<Session, 'id'> means "a Session without the id field"
  // because SQLite generates the id
  const stmt = db.prepare(`INSERT INTO sessions (...) VALUES (?, ?, ?, ?, ?, ?)`);
  // db.prepare() compiles the SQL once, ? are placeholders
  const result = stmt.run(session.name, session.startTime, ...);
  // stmt.run() executes with actual values replacing the ?s
  return result.lastInsertRowid as number;
  // Returns the auto-generated ID
}
```

**Why `db.prepare()` + `stmt.run()` instead of `db.exec()`?**
- `prepare` + `run` uses parameterized queries (? placeholders)
- This prevents SQL injection attacks
- `exec()` is for raw SQL strings (only used for table creation where there's no user input)

**getActiveSession** (line 147):
```typescript
export function getActiveSession(): Session | null {
  const stmt = db.prepare('SELECT * FROM sessions WHERE status = ? ORDER BY id DESC LIMIT 1');
  const row = stmt.get('active') as any;
  // stmt.get() returns ONE row (vs stmt.all() which returns all matching rows)
  if (!row) return null;
  return mapSession(row);  // Converts DB column names (snake_case) to TypeScript (camelCase)
}
```

**getActiveSessionForDir** (line 160): Same but filters by directory.
```typescript
WHERE status = ? AND (working_directory = ? OR git_root = ?)
```
Checks both `working_directory` and `git_root` because a session started in `/project/src` with git root `/project` should match both paths.

**addFileChange / addCommit / addAIUsage** (lines 202-268):
All use the same pattern: **database transaction**.

```typescript
export function addAIUsage(usage: Omit<AIUsage, 'id'>): void {
  const transaction = db.transaction(() => {
    // Step 1: Insert the new record
    const stmt = db.prepare(`INSERT INTO ai_usage (...) VALUES (...)`);
    stmt.run(...);

    // Step 2: Update the session's running totals
    const updateStmt = db.prepare(`
      UPDATE sessions
      SET ai_cost = ROUND((SELECT SUM(cost) FROM ai_usage WHERE session_id = ?) * 10000000000) / 10000000000,
          ai_tokens = (SELECT SUM(tokens) FROM ai_usage WHERE session_id = ?)
      WHERE id = ?
    `);
    updateStmt.run(...);
  });
  transaction();  // Execute both steps atomically
}
```

**Why transactions?** If the app crashes between Step 1 and Step 2, without a transaction you'd have a mismatched total. Transactions guarantee both happen or neither happens.

**Why `ROUND(... * 10000000000) / 10000000000`?** Floating point precision. Without rounding, you get costs like `$0.0018810000000000002`. The multiply-round-divide trick keeps it clean.

### mapSession (line 363):
```typescript
function mapSession(row: any): Session {
  return {
    id: row.id,
    name: row.name,
    startTime: row.start_time,  // DB uses snake_case, TypeScript uses camelCase
    // ...
    aiCost: Math.round((row.ai_cost || 0) * 1e10) / 1e10,  // Same precision fix
  };
}
```

This converts between SQLite's snake_case column names and TypeScript's camelCase property names.

### Pricing System (lines 446-501)

```typescript
const DEFAULT_PRICING: Record<string, { input: number; output: number }> = {
  'claude-opus-4-6': { input: 15, output: 75 },     // $15 per 1M input tokens, $75 per 1M output
  'gpt-4o': { input: 2.50, output: 10 },
  // ...
};
```

Built-in pricing table. Users can override with a `pricing.json` file.

```typescript
export function loadPricing() {
  const merged = { ...DEFAULT_PRICING };  // Start with defaults
  if (existsSync(PRICING_PATH)) {
    const user = JSON.parse(readFileSync(PRICING_PATH, 'utf-8'));
    Object.assign(merged, user);  // User overrides win
  }
  return merged;
}
```

**`Object.assign(merged, user)`** means: copy all properties from `user` into `merged`, overwriting any duplicates.

### Dashboard Queries (lines 503-841)

These are all read-only SQL queries that power the dashboard API. Each one:
1. Runs a SQL query with aggregation (SUM, COUNT, GROUP BY)
2. Maps the result to a TypeScript object

Examples:
- `getDailyCosts()`: Groups sessions by date, sums costs per day
- `getModelBreakdown()`: Groups AI usage by model, shows cost/tokens per model
- `getActivityHeatmap()`: Groups by day-of-week + hour for a heatmap chart
- `getProjectBreakdown()`: Groups by working directory to show cost per project
- `getCostVelocity()`: Calculates cost-per-hour for each session

---

## 3. src/git.ts (Git Integration)

### Session-Scoped Git (lines 1-18)

```typescript
interface GitSession {
  git: SimpleGit;              // simple-git library instance, pointed at a directory
  lastCommitHash: string | null; // Last commit we've seen (for detecting new commits)
  interval?: NodeJS.Timeout;   // The polling interval timer
}

const sessions = new Map<number, GitSession>();  // sessionId -> GitSession
```

**Why a Map?** Each active session has its own git tracker. The Map lets us look up a session's git state by session ID. This enables parallel sessions.

### checkForNewCommits (lines 20-39)

```typescript
export async function checkForNewCommits(sessionId: number): Promise<void> {
  const session = sessions.get(sessionId);
  if (!session) return;

  const log = await session.git.log({ maxCount: 1 });  // Get latest commit
  if (log.latest && log.latest.hash !== session.lastCommitHash) {
    // New commit detected! Save the hash so we don't detect it again
    session.lastCommitHash = log.latest.hash;
    addCommit({
      sessionId,
      hash: log.latest.hash.substring(0, 7),  // Short hash (7 chars)
      message: log.latest.message,
      timestamp: new Date().toISOString(),
    });
  }
}
```

This runs on a timer (every 10 seconds). It checks if git HEAD changed since last check. If yes, record the new commit.

### Git Polling (lines 57-83)

```typescript
export function startGitPolling(sessionId: number, intervalMs: number = 10000): void {
  session.interval = setInterval(async () => {
    await checkForNewCommits(sessionId);
  }, intervalMs);
}

export function stopGitPolling(sessionId: number): void {
  clearInterval(session.interval);  // Stop the timer
}

export function cleanupGit(sessionId: number): void {
  stopGitPolling(sessionId);
  sessions.delete(sessionId);  // Remove from the Map entirely
}
```

**Why `clearInterval`?** If you don't clear it, the timer keeps running forever, even after the session ends. That's a memory leak.

### Utility Functions (lines 88-214)

- **getGitRoot(cwd)**: Runs `git rev-parse --show-toplevel` to find the repo root
- **getGitHead(cwd)**: Runs `git rev-parse HEAD` to get current commit SHA
- **getGitDiffFiles(cwd, fromHead)**: Runs `git diff --name-status fromHead..HEAD` to see what files changed
- **getGitLogCommits(cwd, fromHead)**: Runs `git log from..HEAD` to list commits
- **getGitDiff(cwd, fromSha, toSha)**: Gets the actual diff content (for the dashboard viewer)
- **getGitDiffStats(cwd, fromSha, toSha)**: Gets lines added/deleted per file

All of these wrap the `simple-git` library, which just shells out to the `git` command.

---

## 4. src/watcher.ts (File Watching)

### Setup (lines 1-13)

```typescript
import chokidar from 'chokidar';  // File system watcher library
import { relative } from 'path';   // relative('/project', '/project/src/index.ts') => 'src/index.ts'
import { addFileChange } from './db';

interface WatcherSession {
  watcher: chokidar.FSWatcher;   // The actual file system watcher
  changedFiles: Set<string>;      // Deduplication set (prevents logging same change twice)
  cwd: string;                    // Root directory being watched
  timeouts: Set<NodeJS.Timeout>;  // Pending debounce timers (cleaned up on stop)
}

const sessions = new Map<number, WatcherSession>();
```

Same pattern as git.ts — one watcher per session, stored in a Map.

### startWatcher (lines 15-37)

```typescript
export function startWatcher(sessionId: number, cwd: string): void {
  if (sessions.has(sessionId)) return;  // Don't start duplicate watcher

  const watcher = chokidar.watch(cwd, {
    ignored: /(^|[\/\\])\..|(node_modules|dist|build|\.git)/,
    // ^ Ignores: hidden files (.), node_modules, dist, build, .git
    persistent: true,       // Keep running (don't exit)
    ignoreInitial: true,    // Don't fire events for files that already exist
  });

  watcher
    .on('add', (path) => handleChange(sessionId, path, cwd, 'created'))
    .on('change', (path) => handleChange(sessionId, path, cwd, 'modified'))
    .on('unlink', (path) => handleChange(sessionId, path, cwd, 'deleted'));
}
```

**chokidar** watches the filesystem for changes. When a file is created/modified/deleted, it fires an event. We listen to those events and record them.

### handleChange with Deduplication (lines 73-101)

```typescript
function handleChange(sessionId, path, cwd, changeType) {
  const relativePath = relative(cwd, path);  // Convert absolute path to relative

  const key = `${relativePath}-${changeType}`;
  if (session.changedFiles.has(key)) return;  // Already processed this change recently

  session.changedFiles.add(key);
  const timeout = setTimeout(() => {
    session.changedFiles.delete(key);  // Allow this file to be tracked again after 1 second
    session.timeouts.delete(timeout);
  }, 1000);
  session.timeouts.add(timeout);

  addFileChange({ sessionId, filePath: relativePath, changeType, timestamp: ... });
}
```

**Why deduplication?** When you save a file, many editors trigger multiple filesystem events (write temp file, rename, etc.). Without the 1-second cooldown, you'd get 3-5 records for one save.

### stopWatcher (lines 40-67)

```typescript
export function stopWatcher(sessionId?: number): void {
  session.watcher.close();         // Stop watching
  session.changedFiles.clear();    // Clear dedup set
  for (const timeout of session.timeouts) {
    clearTimeout(timeout);         // Clear all pending timers (prevents memory leaks)
  }
  sessions.delete(sessionId);      // Remove from Map
}
```

---

## 5. src/index.ts (The CLI - Every Command)

This is the longest file (~870 lines). It defines every `cs` command.

### Shebang & Imports (lines 1-38)

```typescript
#!/usr/bin/env node
// ^ This line tells the OS: "run this file with Node.js"
// It's what makes `cs` work as a command in your terminal

import { Command } from 'commander';  // CLI framework: handles arguments, options, help text
import chalk from 'chalk';            // Terminal colors: chalk.green("success"), chalk.red("error")
```

### Program Setup (lines 40-48)

```typescript
const program = new Command();
const pkg = require('../package.json');  // Read version from package.json
const VERSION: string = pkg.version;
const SCHEMA_VERSION = 1;  // JSON output format version (for backwards compatibility)

program
  .name('codesession')
  .description('Track AI coding sessions & agent runs')
  .version(VERSION);  // Makes `cs --version` work
```

### Helper Functions (lines 50-97)

```typescript
function jsonError(code: string, message: string, extra?): never {
  // Outputs a structured JSON error and exits with code 1
  // The `never` return type tells TypeScript this function never returns normally
  console.log(JSON.stringify({ schemaVersion, codesessionVersion, error: { code, message, ...extra } }));
  process.exit(1);
}

function jsonWrap(data): Record<string, any> {
  // Wraps any data with schema version metadata
  // Every JSON output includes schemaVersion and codesessionVersion
  return { schemaVersion, codesessionVersion, ...data };
}

async function resolveActiveSession() {
  // For parallel session support:
  // 1. Find the git root of the current directory
  // 2. Look for an active session matching this directory
  // 3. Fall back to the most recent active session (any directory)
  const cwd = process.cwd();
  const gitRoot = await getGitRoot(cwd);
  const scopeDir = gitRoot || cwd;
  return getActiveSessionForDir(scopeDir) || getActiveSession();
}
```

**Why `resolveActiveSession`?** With parallel sessions, there might be 3 active sessions for 3 different projects. When you run `cs status` from `/project-a`, you want the session for that project, not a random one.

### Pricing Functions (lines 99-143)

```typescript
function lookupPricing(model, provider) {
  const pricing = loadPricing();
  // Try "anthropic/claude-sonnet-4" first (namespaced)
  // Then try "claude-sonnet-4" (plain)
  // Returns null if model is unknown
}

function estimateCost(model, promptTokens, completionTokens, provider) {
  const lookup = lookupPricing(model, provider);
  if (!lookup) return null;
  // Formula: (promptTokens * inputPrice + completionTokens * outputPrice) / 1,000,000
  // Prices are per 1M tokens, so divide by 1M
  const cost = (promptTokens * lookup.entry.input + completionTokens * lookup.entry.output) / 1_000_000;
  return { cost, pricingInfo: { ... } };
}
```

### cs start (lines 145-260)

The most complex command. Here's the flow:

1. **Resolve directory**: Find git root (if in a repo), use it as the session scope
2. **Check for conflicts**:
   - `--resume`: Reuse existing session for this directory
   - `--close-stale`: End all active sessions, start fresh
   - No flags: Block if same-directory session exists, allow if different directory
3. **Create session**: Insert into SQLite, get back the session ID
4. **Start tracking**:
   - `initGit()` — Initialize git tracking
   - `startWatcher()` — Start file watching (only in interactive mode, not `--json`)
   - `startGitPolling()` — Start commit polling every 10s

**Why no watcher in `--json` mode?** When an AI agent calls `cs start --json`, it just needs the session ID. Watchers would waste resources since agent sessions are typically short-lived and tracked via `cs log-ai` instead.

### cs end (lines 262-344)

Flow:
1. Find the active session (by ID or auto-resolve by directory)
2. Stop watchers and git polling
3. **Git-based final scan**: Compare current HEAD to the HEAD when session started, find all files changed and commits made. This catches changes the watcher might have missed.
4. End the session in the DB (calculate duration)
5. Output summary

### cs log-ai (lines 436-543)

The command AI agents call to report their usage:

```bash
cs log-ai -p anthropic -m claude-sonnet-4 --prompt-tokens 5000 --completion-tokens 1000 --json
```

Flow:
1. Find active session
2. Calculate tokens (from flags)
3. Calculate cost:
   - If `--cost` provided: use it directly
   - If not: look up model in pricing table, calculate automatically
   - If model unknown and no cost: error
4. Insert AI usage record
5. Update session totals

### cs auto-log (lines 724-856)

This is the Claude Code hook integration. Called automatically, not by users.

```
Claude Code fires "Stop" event -> pipes JSON to stdin -> cs auto-log reads it
```

Flow:
1. **TTY check**: If stdin is a terminal (not piped), exit with error
2. **Read stdin**: Get the hook JSON (contains transcript_path, session_id)
3. **Find active session**: Exit silently if none (don't save position = don't lose tokens)
4. **Position tracking**: Read how far we've already processed in the transcript
5. **Parse transcript**: Each line is a JSON message with role and content
6. **Estimate tokens**: ~1 token per 4 characters (rough but consistent)
7. **Log usage**: Insert into DB
8. **Save position**: AFTER successful log (prevents data loss)

**Critical bug that was fixed**: Originally, position was saved BEFORE checking if a session existed. If no session, the lines were marked "processed" but never logged. Tokens permanently lost.

### Other Commands

- **cs status**: Shows current session info
- **cs show [id]**: Shows details of any session
- **cs list / cs ls**: Lists recent sessions
- **cs stats**: Aggregate statistics
- **cs export**: Export to JSON or CSV
- **cs pricing list/set/reset**: Manage model pricing
- **cs note "message"**: Add a timestamped annotation
- **cs recover**: Auto-end sessions that have been active for over 24h (crash recovery)
- **cs dashboard**: Launches the web dashboard (imports dashboard-server.ts)

### Program Entry Point (lines 858-868)

```typescript
if (require.main === module) {
  program.parse();  // Only parse CLI args when run directly
}
// When imported as a library (require('codesession-cli')), don't parse CLI args
// Instead, export all the functions for programmatic use
```

---

## 6. src/agents.ts (The Programmatic SDK)

This lets developers use codesession from code, not just CLI:

```typescript
const session = new AgentSession('Refactor auth module', {
  budget: 5.00,       // Hard cap: auto-end if exceeded
  directory: './src',
  git: true,
});

session.start();           // Creates session, starts watchers
session.logAI('anthropic', 'claude-sonnet-4', 5000, 0.05);  // Log AI usage
const summary = session.end();  // Returns full summary
```

### AgentSession Class (lines 69-276)

**Key properties:**
- `sessionId`: The SQLite ID
- `totalCost` / `totalTokens`: Running in-memory totals
- `started` / `ended`: State flags (prevents double-start or use-after-end)

**start()** (line 91): Creates DB session + starts watcher + starts git polling

**logAI()** (line 131): The budget enforcement happens here:
```typescript
// Check budget BEFORE writing to database
const newTotalCost = this.totalCost + cost;
if (this.config.budget !== undefined && newTotalCost > this.config.budget) {
  throw new BudgetExceededError(newTotalCost, this.config.budget);
  // ^ Does NOT write to DB. The agent catches this error and stops.
}
// Budget OK -- safe to write
addAIUsage({ ... });
```

**Why check BEFORE writing?** If you write first and check after, the over-budget usage is already recorded. By checking first, you prevent the overspend from being logged at all.

**end()** (line 207): Stops watchers, ends DB session, builds a summary object with all files/commits/costs.

**canAfford(estimatedCost)** (line 263): Pre-flight check. Before making an expensive API call, the agent can ask "can I afford this?"

### BudgetExceededError (lines 293-303)

Custom error class. Agents can catch this specifically:
```typescript
try {
  session.logAI(...);
} catch (e) {
  if (e instanceof BudgetExceededError) {
    // Handle gracefully: save work, clean up, etc.
  }
}
```

### runAgentSession Helper (lines 321-385)

Convenience wrapper that handles start/end/errors:
```typescript
const summary = await runAgentSession('Fix bugs', { budget: 3.00 }, async (session) => {
  // Your agent code here
  // If it throws, session auto-ends with error note
  // If budget exceeded, session auto-ends cleanly
});
```

---

## 7. src/dashboard-server.ts (The Web Dashboard Backend)

### PID File Management (lines 26-96)

When you run `cs dashboard`, it writes its process ID to `~/.codesession/dashboard-3737.pid`. This lets the next `cs dashboard` detect and kill the old one.

```typescript
function writePidFile(port): void {
  writeFileSync(pidFilePath(port), `${process.pid}\n`);
}

function killOwnStaleProcess(port): boolean {
  const pid = readOwnPid(port);
  // Verify it's actually a dashboard process (not a recycled PID)
  // Kill it, return true if successful
}
```

**Why check the command line?** Process IDs get recycled. PID 12345 might have been a dashboard last week, but now it's Chrome. We verify before killing.

### Port Check (lines 98-112)

```typescript
function isPortInUse(port): Promise<boolean> {
  // Try to create a TCP server on the port
  // If it fails with EADDRINUSE, the port is taken
  // If it succeeds, the port is free (close the server immediately)
}
```

### API Router (lines 116-366)

Every dashboard endpoint is defined here. They all follow the same pattern:

```typescript
router.get('/stats', (_req, res) => {
  try {
    const stats = getStats();        // Call the db.ts function
    res.json({ ...stats, ... });     // Return as JSON
  } catch (e: any) {
    res.status(500).json({ error: e.message });
  }
});
```

Endpoints:
- `GET /stats` - Overview KPIs
- `GET /sessions` - Paginated session list (supports ?status=, ?search=)
- `GET /sessions/:id` - Single session detail
- `GET /sessions/:id/diff` - Git diff for a session
- `GET /sessions/:id/commits/:hash/diff` - Single commit diff
- `GET /sessions/:id/diff-stats` - Lines added/deleted per file
- `GET /daily-costs` - Cost chart data
- `GET /model-breakdown` - Cost per model
- `GET /top-sessions` - Most expensive sessions
- `GET /provider-breakdown` - Cost per provider (Anthropic vs OpenAI)
- `GET /file-hotspots` - Most frequently changed files
- `GET /activity-heatmap` - When you code (hour x day grid)
- `GET /daily-tokens` - Token usage chart
- `GET /cost-velocity` - Cost per hour trend
- `GET /projects` - Cost per project directory
- `GET /token-ratios` - Input vs output tokens per model
- `GET /pricing` - Current pricing table
- `GET /export` - Download sessions as JSON or CSV
- `GET /version` - App version
- `POST /reset` - Delete all data ("Start Fresh")

### Server Startup (lines 370-566)

```typescript
export function startDashboard(options) {
  const app = express();  // Create Express HTTP server

  // Security headers (lines 391-406)
  app.disable('x-powered-by');  // Don't reveal "Express" in headers
  res.setHeader('X-Content-Type-Options', 'nosniff');  // Prevent MIME sniffing
  res.setHeader('X-Frame-Options', 'DENY');  // Prevent embedding in iframes

  // Token auth for non-localhost (lines 411-423)
  // If you bind to 0.0.0.0 (network-exposed), a random token is generated
  // All API requests must include ?token=xxx or Authorization: Bearer xxx

  // Static files (lines 425-445)
  // Hashed assets (JS/CSS with content hash in filename): cached for 1 year
  // index.html: never cached (so upgrades take effect immediately)

  // SPA fallback (lines 460-481)
  // All routes (/sessions, /models, etc.) serve the same index.html
  // React handles the routing client-side
  app.get('/', sendSpa);
  app.get('/sessions', sendSpa);
  app.get('/sessions/:id', sendSpa);
  // etc.
}
```

**What's a SPA fallback?** The dashboard is a Single Page Application. When you navigate to `/sessions`, the browser requests that URL from the server. The server doesn't have a `/sessions` page -- it serves `index.html`, and React's client-side router figures out which page to show.

---

## 8. Dashboard Frontend (Quick Overview)

### App.tsx - Custom Router

```typescript
function parseRoute() {
  const path = window.location.pathname;
  if (path === '/sessions') return { page: 'sessions' };
  if (path === '/models') return { page: 'models' };
  // etc.
}

// Navigation without page reload:
const navigate = (p: Page) => {
  window.history.pushState(null, '', buildPath(p));  // Update URL bar
  setPage(p);  // Update React state (triggers re-render)
};
```

**Why no React Router?** The routing is simple enough (6 pages) that a 20-line custom solution works fine. No extra dependency needed.

### Sidebar.tsx - Navigation

```typescript
const NAV = [
  { page: 'overview', icon: <IconOverview />, label: 'Overview' },
  { page: 'sessions', icon: <IconSessions />, label: 'Sessions' },
  // ...
  { page: 'donate', icon: <IconHeart />, label: 'Donate' },
];
```

Maps through NAV array, renders buttons, highlights active page.

### Page Components

Each page fetches data from the API and renders it:
```typescript
// Inside a page component:
useEffect(() => {
  fetchApi('/api/v1/stats').then(setStats);
}, []);

// Auto-refresh every 30 seconds:
useInterval(() => {
  fetchApi('/api/v1/stats').then(setStats);
}, 30000);
```

---

## Key Concepts to Remember

1. **Data flows one direction**: CLI/Agent -> SQLite DB -> REST API -> React Dashboard
2. **SQLite is the single source of truth**: Everything reads/writes the same `~/.codesession/sessions.db`
3. **Every CLI command has a `--json` flag**: Human-readable output by default, structured JSON for agents
4. **Sessions are directory-scoped**: Parallel sessions work because each directory has its own session
5. **Cost calculation**: `(prompt_tokens * input_price + completion_tokens * output_price) / 1,000,000`
6. **WAL mode + transactions**: Handles concurrent access (CLI + dashboard reading same DB)
7. **Position-based deduplication in auto-log**: Prevents double-counting Claude Code hook events
8. **Budget enforcement is pre-write**: Check BEFORE inserting, not after

---

## Questions They Might Ask

**"Why SQLite and not PostgreSQL/MongoDB?"**
Local-first tool. Zero config. No server to run. Data stays on the user's machine. SQLite handles millions of rows easily for this use case.

**"How do you handle concurrent access?"**
WAL mode allows concurrent readers. busy_timeout handles write contention. Transactions ensure atomicity.

**"Why TypeScript?"**
Type safety catches bugs at compile time. The interfaces in types.ts act as documentation. IDE autocomplete makes development faster.

**"What happens if the process crashes?"**
The `recover` command finds sessions active for >24h and auto-closes them. WAL mode protects against DB corruption from crashes.

**"How accurate is the token estimation in auto-log?"**
Rough estimate: ~1 token per 4 characters. Not exact, but consistent. For precise tracking, users should use `cs log-ai` with actual token counts from the API response.

**"Why not use the Anthropic/OpenAI API to get exact costs?"**
We don't intercept API calls. We're a logging tool, not a proxy. Users tell us what they used, or Claude Code's transcript gives us a rough estimate.
